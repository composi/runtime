{"version":3,"file":"runtime.mjs.map","sources":["../src/runtime.js","../src/union.js","../src/effects.js"],"sourcesContent":["/**\n * @typedef {Object<string, any>} Message\n * @prop {string} type\n * @prop {any} [data]\n * @typedef {(msg?: Message) => Message} Send\n * @typedef {() => State} GetState\n */\n/**\n * @typedef {any} State Simple or complex types for application state.\n */\n/**\n * @typedef {State | void} InitResult Return result of program init method.\n */\n/**\n * @typedef {Object<string, any>} Program A program to run.\n * @prop {() => InitResult} init Method to set up initial state.\n * @prop {(state: State, send?: Send) => void} view Method to present the current application state.\n * @prop {(state: State, msg?: Message, send?: Send) => any} update Method to capture messages sent from view or subscriptions. According to the message, an action will transform application state and pass it the the program view method.\n * @prop {(send?: Send, getState?: GetState) => void} [subscriptions] Method to run effects when the program starts. These run independently from the rest of the program.\n * @prop {(send?: Send, getState?: GetState) => void} [subs] Shortcut for subscriptions.\n * @prop {(state: State) => void} [done] Method to do clean up when shutting down a program.\n * @prop {Send} [send] A static send function for dispatching message to a program. Used with routers and in composition.\n */\n/**\n * The @composi/runtime.\n * @example\n *\n * ```\n * // Create a runtime program\n * const program = {\n *   // Define state:\n *   init() {\n *     return [{count: 0}]\n *   },\n *   // Define view to render.\n *   // Notice event to send message 'incr'.\n *   view(state, send) {\n *      return render(<div onclick={send('incr')}>The count is: {state.count}</div>, document.body)\n *   },\n *   // Define action to update state:\n *   update(state, msg) {\n *     if (msg === 'incr') {\n *        return [state.count++]\n *     }\n *   }\n * }\n * // Run the program:\n * run(program)\n * ```\n * @param {Program} program A program to run with five methods: `init`, `view`, `update`, `subscriptions` and `done`.\n * @return {() => void} Function to terminate runtime.\n */\nexport function run(program) {\n  let init = program.init\n  const view = program.view\n  const update = program.update\n  const subscriptions = program.subscriptions || program.subs\n  const done = program.done\n  let state\n  let isRunning = true\n  let isFirstRun = true\n  const getState = () => state\n\n  /**\n   * Send a message.\n   * @param {Message} message\n   *\n   */\n  function send(message) {\n    if (isRunning) {\n      return updateView(update(state, message, send))\n    }\n  }\n\n  /**\n   * Expose send as static function on program object.\n   * This is to let you send messages to the program\n   * from other contexts, such as in a @composi/router action.\n   */\n  program['send'] = send\n\n  /**\n   * Handle changes to state and executing effects.\n   * @param {any} update\n   * @return {void} undefined\n   */\n  function updateView(update) {\n    if (update) {\n      state = update\n    } else if (init) {\n      state = init()\n    }\n    if (subscriptions && isFirstRun) {\n      if (typeof subscriptions === 'function') subscriptions(send, getState)\n      isFirstRun = false\n    }\n    view(state, send)\n  }\n  updateView(state)\n\n  /**\n   * Function to end runtime.\n   * @return {void} undefined\n   */\n  return () => {\n    if (isRunning) {\n      isRunning = false\n      if (done) {\n        done(state)\n      }\n    }\n  }\n}\n","const hasOwnProperty = Object.prototype.hasOwnProperty\n\n/**\n * @typedef {Object} Tag\n * @prop {string} type\n * @prop {any} [data]\n */\n/**\n * @param {Tag} tag\n * @param {Object<string, Function>} handlers\n */\nfunction match(tag, handlers) {\n  if (!tag.type) {\n    console.error(\n      \"The message you provided was not valid. Messages have the format: {type: 'whatever', data: 'something'}\"\n    )\n    console.error('The tag you provided was:')\n    console.dir(tag)\n    return\n  }\n  return ((tag, context) => {\n    const type = tag.type\n    const match = hasOwnProperty.call(handlers, type) && handlers[type]\n    return match(tag.data, context)\n  })(tag)\n}\n\n/**\n * Create a union of string tags.\n * @param {string[]} types\n * @returns {Object<string, any>} Object\n */\nfunction createUnion(types) {\n  const variants = Object.create(null)\n\n  let idx = 0\n  while (idx < types.length) {\n    const type = types[idx]\n    variants[type] = data => ({ type, data })\n    idx++\n  }\n\n  return { variants, match }\n}\n\n/**\n * @typedef {Object} MessageUnion\n */\n\n/**\n * Create a union of types for matching up with functions. This is used to define actions for the `update` method of a runtime program.\n * @param {...string} types\n * @returns {MessageUnion} MessageUnion\n */\nexport function union(...types) {\n  const { variants, match } = createUnion(types)\n  variants.match = match\n  return variants\n}\n","/**\n * @typedef {import('./runtime').Send} Send\n * @typedef {import('./runtime').Message} Message\n * @typedef {Object} State\n * @typedef {() => State} GetState\n * @typedef {(send?: Send, getState?: GetState) => any} Effect\n */\n/**\n * Function to batch effects together.\n * @param {...Effect} effects\n * @return {(send?: Send, getState?: GetState) => void} Function\n */\nexport const batchEffects = (...effects) => (getState, send) =>\n  effects.map(effect => effect && effect(getState, send))\n\nexport const batch = batchEffects\n"],"names":["run","program","send","message","isRunning","updateView","update","state","init","subscriptions","isFirstRun","getState","view","subs","done","hasOwnProperty","Object","prototype","match","tag","handlers","type","context","call","data","console","error","dir","createUnion","types","variants","create","idx","length","union","batchEffects","effects","map","effect","batch"],"mappings":"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"}